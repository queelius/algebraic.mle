[{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://queelius.github.io/algebraic.mle/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://queelius.github.io/algebraic.mle/articles/dgp.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Dynamic failure rate model","text":"algebraic.mle can installed GitHub using devtools package R:","code":"install.packages(\"devtools\") devtools::install_github(\"queelius/algebraic.mle\")"},{"path":"https://queelius.github.io/algebraic.mle/articles/dgp.html","id":"purpose","dir":"Articles","previous_headings":"","what":"Purpose","title":"Dynamic failure rate model","text":"primary focus package likelihood log-likelihood, fundamental statistical concepts parametric model. integral Bayesian frequentist statistics, well prioritize likelihood. algebraic.mle package enables easy handling MLEs, , certain conditions assumptions (independence identical distribution (iid) sample), present numerous advantages, including asymptotic normality uniformly minimum variance unbiased estimator theta.","code":""},{"path":"https://queelius.github.io/algebraic.mle/articles/dgp.html","id":"api-overview","dir":"Articles","previous_headings":"","what":"API Overview","title":"Dynamic failure rate model","text":"main object algebraic.mle package mle object, represents fitted model. package provides number generic methods designed mle objects. comprehensive list functions available function reference algebraic.mle.","code":""},{"path":"https://queelius.github.io/algebraic.mle/articles/dgp.html","id":"fitting-exponential-models","dir":"Articles","previous_headings":"","what":"Fitting exponential models","title":"Dynamic failure rate model","text":"example fitting conditional exponential model data using algebraic.mle. true DGP given Y | x ~ X(x) + W$ X(x) ~ EXP(rate(x)), W ~ N(0, 1e-3), rate(x) = exp(b0 + b1 * x). analysis, care x distributed, take observable exogenous variable. interested conditional distribution Y | x. Let’s fit conditional exponential model data DGP. true DGP bit complicated, salient part exponential component, gaussian term may thought added noise, say, imprecise measurement. course, true DGP unknown practice, arriving conditional exponential model matter judgement domain knowledge. model, Y | x ~ EXP(rate(x)) rate(x) = exp(b0 + b1*x). First, let’s define DGP (data generating process): Let’s generate date: Now, define two functions, resp, rate, loglik function used define model. Let’s fit model. ’ll use optim function stats fit model wrap mle object using mle_numerical. Let’s plot :","code":"library(algebraic.dist) #> Registered S3 method overwritten by 'algebraic.dist': #>   method     from  #>   print.dist stats b0 <- -.1 b1 <- 0.5  dgp <- function(n, x) {     rate <- exp(b0 + b1 * x)     X <- rexp(n, rate)     W <- rnorm(n, 0, 1e-3)     return(X + W) } n <- 75 # number of observations set.seed(1231) # for reproducibility df <- data.frame(x = rep(NA, n), y = rep(NA, n)) for (i in 1:n) {     x <- runif(1, -10, 10)     y <- dgp(n = 1, x = x)     df[i, ] <- c(x, y) } resp <- function(df) df$y rate <- function(df, beta) exp(beta[1] + beta[2] * df$x) loglik <- function(df, resp, rate) {   function(beta) sum(dexp(x = resp(df), rate = rate(df, beta), log = TRUE)) } library(algebraic.mle)  # initial guess for the parameters par0 <- c(0, 0) names(par0) <- c(\"b0\", \"b1\")  sol <- mle_numerical(optim(par = par0,     fn = loglik(df, resp, rate),     control = list(fnscale = -1),     hessian = TRUE)) summary(sol) #> Maximum likelihood estimator of type mle_numerical is normally distributed. #> The estimates of the parameters are given by: #>         b0         b1  #> -0.2253626  0.4560893  #> The standard error is  0.1167634 0.02145606 . #> The asymptotic 95% confidence interval of the parameters are given by: #>          2.5%       97.5% #> b0 -0.4542147 0.003489406 #> b1  0.4140362 0.498142415 #> The MSE of the individual components in a multivariate estimator is: #>              [,1]         [,2] #> [1,] 0.0136336902 0.0003746527 #> [2,] 0.0003746527 0.0004603623 #> The log-likelihood is  -119.6977 . #> The AIC is  243.3954 . # plot the x-y points from the data frame plot(df$x,df$y)  # now overlay a plot of the conditional mean x <- seq(-10, 10, .1) b0.hat <- params(sol)[1] b1.hat <- params(sol)[2] y.hat <- 1/exp(b0.hat + b1.hat*x) y <- 1/exp(b0 + b1*x) lines(x, y, col = \"green\", lwd = 10) lines(x, y.hat, col = \"blue\", lwd = 10)"},{"path":"https://queelius.github.io/algebraic.mle/articles/dgp.html","id":"hypothesis-test-and-model-selection","dir":"Articles","previous_headings":"Fitting exponential models","what":"Hypothesis test and model selection","title":"Dynamic failure rate model","text":"Let’s test hypothesis b0 = 0 using likelihood ratio test. can use LRT null model special case (nested) full model. null model Y | x ~ EXP(rate(x)) rate(x) = exp(b1*x), full model Y | x ~ EXP(rate(x)) rate(x) = exp(b0 + b1*x). Let’s compute likelihood ratio test statistic p-value: see p < 0.05, just barely, say data compatible null hypothesis b0 = 0. wanted model selection, use AIC: AIC measure, since full model AIC less null model, choose full model. actually know DGP models reasonable approximations, full model closer approximation. “models wrong, useful.” - George Box Eventually, sufficiently large sample, model DGP can discarded, reality complex never large enough sample never able come model exactly DGP. Let’s another test, b1 = 0, .e., ’s unconditional exponential model, just standard exponential distribution. p-value essentially zero, reject null hypothesis b1 = 0. Let’s compare confidence intervals models. see 95% confidence interval b0 include zero, reject null hypothesis b0 = 0. 95% confidence interval b1 include zero, reject null hypothesis b1 = 0. can see tutorials examples using package vignettes.","code":"# construct null model where b1 = 0 rate_b0_zero <- function(df, b1) exp(b1 * df$x)  # initial guess for the parameters # fit the model under the null hypothesis sol2 <- mle_numerical(optim(par = 0,     fn = loglik(df, resp, rate_b0_zero),     control = list(fnscale = -1),     hessian = TRUE,     method = \"BFGS\")) summary(sol2) #> Maximum likelihood estimator of type mle_numerical is normally distributed. #> The estimates of the parameters are given by: #> [1] 0.4617093 #> The standard error is  0.01899941 . #> The asymptotic 95% confidence interval of the parameters are given by: #>             2.5%     97.5% #> param1 0.4244712 0.4989475 #> The MSE of the estimator is  0.0003609774 . #> The log-likelihood is  -121.7164 . #> The AIC is  245.4328 . (lrt.sol2 <- -2 * (loglik_val(sol2) - loglik_val(sol))) #> [1] 4.037435 pchisq(lrt.sol2, df = 1, lower.tail = FALSE) # compute the p-value #> [1] 0.04450142 aic(sol) #> [1] 243.3954 aic(sol2) #> [1] 245.4328 rate_b1_zero <- function(df, b0) exp(b0) # fit the model under the null hypothesis sol3 <- mle_numerical(optim(par = 0,     fn = loglik(df, resp, rate_b1_zero),     control = list(fnscale = -1),     hessian = TRUE,     method = \"BFGS\")) (lrt.sol3 <- -2 * (loglik_val(sol2) - loglik_val(sol))) #> [1] 4.037435 pchisq(lrt.sol3, df = 1, lower.tail = FALSE) # compute the p-value #> [1] 0.04450142 CI <- confint(sol) # print the confidence interval print(CI) #>          2.5%       97.5% #> b0 -0.4542147 0.003489406 #> b1  0.4140362 0.498142415"},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Fitting Common Distributions to a DGP","text":"goal vignette demonstrate using R package algebraic.mle inference maximum likelihood estimators (MLEs). simulate dataset whose true data generating process (DGP) mixture Weibull Normal distributions. However, fit Weibull Normal distributions separately data explore provides better fit.","code":""},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"data-simulation","dir":"Articles","previous_headings":"","what":"Data Simulation","title":"Fitting Common Distributions to a DGP","text":"First, simulation parameters: simulate sample size \\(n = 100\\) DGP: \\[     T_i = W_i + \\epsilon_i \\] \\[     W_i \\sim \\operatorname{Weibull}(k = 2, \\lambda = 10) \\] \\[     \\epsilon_i \\sim \\operatorname{normal}(\\mu = 0, \\sigma = 0.1). \\] can simulate sample DGP mixture distribution using rweibull rnorm functions:","code":"n <- 100 err <- 0.1 shape <- 2 scale <- 10 theta = c(shape, scale) set.seed(142334) x <- rweibull(n = n, shape = shape, scale = scale) +   rnorm(n = n, mean = 0, sd = err)"},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"visualizing-data","dir":"Articles","previous_headings":"","what":"Visualizing Data","title":"Fitting Common Distributions to a DGP","text":"observations: Visualizing data good first step analysis data. data univariate bivariate, can plot histogram data pretty easily. show histogram simulated data :","code":"head(x, n = 4) #> [1]  6.69  2.96 13.05  5.34"},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"parametrically-modeling-the-data","dir":"Articles","previous_headings":"","what":"Parametrically Modeling the Data","title":"Fitting Common Distributions to a DGP","text":"sample, might conclude? can difficult problem. interested , say, prediction, sufficiently large sample, use non-parametric methods “let data speak .” However, interested inference (e.g., explaining data) sample small, usually need make assumptions data. case, assume data drawn parametric distribution. many well-known, named parametric distributions, e.g., Pareto, Weibull, Normal, name . fit Weibull Normal distributions, compare results.","code":""},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"maximum-likelihood-estimation","dir":"Articles","previous_headings":"","what":"Maximum Likelihood Estimation","title":"Fitting Common Distributions to a DGP","text":"use maximum likelihood estimation (MLE) estimate parameters Weibull Normal, wrap estimates mle object provided algebraic.mle package: Let’s plot pdfs Weibull normal distributions: purple, true density (DGP). red, Weibull density. green, normal density. plot, ’s hard tell distribution better fit DGP. Interestingly, tails true distribution seem bit heavier tails Weibull Normal. may suggest heavier-tailed model may better fit, lognormal distribution, pursue .","code":"fit_normal <- function(data) {     loglik <- function(theta) {         sum(dnorm(data, mean = theta[1], sd = sqrt(theta[2]), log = TRUE))     }     mu.hat <- mean(data)     sigma2.hat <- mean((data - mu.hat)^2)     H <- -numDeriv::hessian(loglik, c(mu.hat, sigma2.hat))     mle(theta.hat = c(mu.hat, sigma2.hat),         loglike = loglik(c(mu.hat, sigma2.hat)),         score = numDeriv::grad(loglik, c(mu.hat, sigma2.hat)),         sigma = MASS::ginv(H),         info = H,         obs = data,         nobs = length(data),         superclasses = c(\"mle_normal\")) }  fit_weibull <- function(data) {     loglik <- function(theta) {         sum(dweibull(data, shape = theta[1], scale = theta[2], log = TRUE))     }      sol <- stats::optim(         par = c(shape, scale),         fn = loglik,         hessian = TRUE,         method = \"L-BFGS-B\",         lower = c(0, 0),         #method = \"Nelder-Mead\",         control = list(maxit = 10000, fnscale = -1))      mle(theta.hat = sol$par,         loglike = sol$value,         sigma = MASS::ginv(-sol$hessian),         info = -sol$hessian,         obs = data,         nobs = length(data),         superclasses = c(\"mle_weibull\")) }  bias.mle_normal <- function(x, theta = NULL) {     if (is.null(theta))         theta <- params(x)     c(0, -theta[2] / nobs(x)) }  theta.hat <- fit_normal(x) summary(theta.hat) #> Maximum likelihood estimator of type mle_normal is normally distributed. #> The estimates of the parameters are given by: #> [1]  8.23 19.11 #> The standard error is  0.437 2.7 . #> The asymptotic 95% confidence interval of the parameters are given by: #>         2.5% 97.5% #> param1  7.37  9.09 #> param2 13.82 24.41 #> The MSE of the individual components in a multivariate estimator is: #>                  [,1]             [,2] #> [1,] 0.19112701130551 0.00000000000607 #> [2,] 0.00000000000607 7.34243642454061 #> The log-likelihood is  -289 . #> The AIC is  583 .  theta.weibull <- fit_weibull(x) summary(theta.weibull) #> Maximum likelihood estimator of type mle_weibull is normally distributed. #> The estimates of the parameters are given by: #> [1] 1.95 9.27 #> The standard error is  0.153 0.5 . #> The asymptotic 95% confidence interval of the parameters are given by: #>        2.5% 97.5% #> param1 1.65  2.25 #> param2 8.29 10.25 #> The MSE of the individual components in a multivariate estimator is: #>        [,1]   [,2] #> [1,] 0.0235 0.0237 #> [2,] 0.0237 0.2497 #> The log-likelihood is  -284 . #> The AIC is  573 ."},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"performance-measures-of-the-mle","dir":"Articles","previous_headings":"Maximum Likelihood Estimation","what":"Performance Measures of the MLE","title":"Fitting Common Distributions to a DGP","text":"nice property MLEs , asymptotically, given regularity conditions, normally distributed mean given true true parameter variance-covariance given inverse FIM evaluated \\(\\theta\\). know \\(\\theta\\), estimates, thus may approximate sampling distribution \\(\\hat\\theta\\) \\(\\mathcal{N}(\\hat\\theta,^{-1}(\\hat\\theta))\\). Let \\(F\\) denote true distribution function \\(X_j \\sim F\\) \\(j\\). Suppose population parameter \\(\\theta = t(F)\\) estimator \\(\\theta\\) given \\(\\hat\\theta = s(\\{X_1,\\ldots,X_n\\})\\). reasonable requirement estimator \\(\\hat\\theta\\) converges true parameter value \\(\\theta\\) collect data. particular, say consistent estimator \\(\\theta\\) \\(\\hat\\theta\\) converges probability \\(\\theta\\), denoted \\(\\hat\\theta \\overset{p}{\\mapsto} \\theta\\). regularity conditions hold MLE, \\(\\hat\\theta\\) consistent estimator \\(\\theta\\). However, finite sample sizes, estimator may biased. bias \\(\\hat\\theta\\) respect \\(\\theta\\) defined \\[     \\operatorname{bias}(\\hat\\theta,\\theta) = E(\\hat\\theta) - \\theta, \\] \\(\\operatorname{bias}(\\hat\\theta,\\theta) = 0\\) indicates \\(\\hat\\theta\\) unbiased estimator \\(\\theta\\). function true distribution \\(F\\), bias unknown statistic. However, case normal, \\(\\hat\\mu\\) unbiased , analytically, bias \\(\\hat\\sigma^2\\) given \\(-\\frac{1}{n} \\sigma^2\\): \\(\\sigma^2\\) known, may estimate using replacing \\(\\hat\\sigma^2\\) instead: pretty far true bias. may first indication DGP far normal. wanted estimate bias Weibull, bootstrap something else, don’t attempt . mean squared error (MSE) another performance measure estimator. given \\[     \\operatorname{mse}(\\hat\\theta) = E\\bigl\\{(\\hat\\theta - \\theta)^T(\\hat\\theta - \\theta)\\bigr\\}, \\] Another way compute MSE given \\[     \\operatorname{mse}(\\hat\\theta) =         \\operatorname{trace}(\\operatorname{cov}(\\hat\\theta) +         \\operatorname{bias}(\\hat\\theta)^T         \\operatorname{bias}(\\hat\\theta). \\] ’s R code compute MSE \\(\\hat\\theta\\): normal distribution significant MSE compared Weibull.","code":"bias(theta.hat,theta) #> [1]  0.0 -0.1 bias(theta.hat) #> [1]  0.000 -0.191 round(mse(theta.hat), digits=3) #>       [,1] [,2] #> [1,] 0.191 0.00 #> [2,] 0.000 7.34 round(mse(theta.weibull), digits=3)  # true MSE #>       [,1]  [,2] #> [1,] 0.023 0.024 #> [2,] 0.024 0.250"},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"invariance-property-of-the-mle","dir":"Articles","previous_headings":"","what":"Invariance Property of the MLE","title":"Fitting Common Distributions to a DGP","text":"interesting property MLE \\(\\hat\\theta\\) MLE \\(f(\\theta)\\) given \\(f(\\hat\\theta)\\). distribution \\(f(\\hat\\theta)\\)? Asymptotically, normally distributed mean given \\(f(\\theta)\\) variace-covariance given covariance sampling distribution \\(f(\\hat\\theta)\\). provide two methods compute variance-covariance.","code":""},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"delta-method","dir":"Articles","previous_headings":"Invariance Property of the MLE","what":"Delta Method","title":"Fitting Common Distributions to a DGP","text":"\\(f\\) differentiable, variance-covariance given \\[ \\operatorname{var}(f(\\hat\\theta)) = \\operatorname{E}\\bigl\\{     \\bigl(f(\\hat\\theta) - f(\\theta)\\bigr)^2\\bigr\\} =     \\operatorname{E}\\bigl\\{J_f(\\hat\\theta) (\\hat\\theta)^{-1} J_f(\\hat\\theta)^T\\bigr\\}. \\] , \\(J_f(\\hat\\theta)\\) Jacobian \\(f\\) evaluated \\(\\hat\\theta\\).","code":""},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"monte-carlo-method","dir":"Articles","previous_headings":"Invariance Property of the MLE","what":"Monte-Carlo Method","title":"Fitting Common Distributions to a DGP","text":"delta method requires \\(f\\) differentiable, may use Monte-carlo method estimate distribution \\(f(\\hat\\theta)\\) function \\(f\\). simply sample MLE \\(\\hat\\theta\\) apply \\(f\\) estimates take covariance sample. Next, show compute sampling distribution \\(g(\\hat\\theta)\\) function \\(g\\) MLE \\(\\hat\\theta\\) using delta mc methods.","code":""},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"example-1","dir":"Articles","previous_headings":"Invariance Property of the MLE","what":"Example 1","title":"Fitting Common Distributions to a DGP","text":"example, use Weibull fit. Let \\(g(\\theta) = \\theta + b\\) matrix \\(\\) vector \\(b\\). (simple linear transformation \\(\\theta\\).) can define \\(g\\) R : compute variance-covariance MLE \\(g(\\theta)\\) using methods: pretty close.","code":"A <- matrix(c(2,3),nrow=2) b <- c(1,0) g <- function(x) A %*% x + b g.mc <- rmap(theta.weibull,g,n=100000L) g.delta <- rmap(theta.weibull,g,method=\"delta\") round(vcov(g.mc), digits=3) #>       [,1]  [,2]  [,3]  [,4] #> [1,] 0.095 0.142 0.095 0.143 #> [2,] 0.142 0.213 0.143 0.214 #> [3,] 0.095 0.143 1.003 1.504 #> [4,] 0.143 0.214 1.504 2.256 round(vcov(g.delta), digits=3) #>       [,1]  [,2]  [,3]  [,4] #> [1,] 0.094 0.141 0.095 0.142 #> [2,] 0.141 0.211 0.142 0.213 #> [3,] 0.095 0.142 0.999 1.498 #> [4,] 0.142 0.213 1.498 2.247"},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"weighted-mle-a-weighted-sum-of-mles","dir":"Articles","previous_headings":"","what":"Weighted MLE: A Weighted Sum of MLEs","title":"Fitting Common Distributions to a DGP","text":"Since variance-covariance MLE inversely proportional Fisher information MLE defined respect , can combine multiple MLEs \\(\\theta\\), may defined respect different kind sample, arrive MLE incorporates Fisher information samples. Consider \\(k\\) mutually independent MLEs parameter \\(\\theta\\), \\(\\hat\\theta_1,\\ldots,\\hat\\theta_k\\), \\(\\hat\\theta_j \\sim N(\\theta,I_j^{-1}(\\theta))\\). , sampling MLE \\(\\theta\\) incorporates data \\(\\hat\\theta_1,\\ldots,\\hat\\theta_k\\) given inverse-variance weighted mean, \\[     \\hat\\theta_w = \\left(\\sum_{j=1}^k I_j(\\theta)\\right)^{-1} \\left(\\sum_{j=1}^k I_j(\\theta) \\hat\\theta_j\\right), \\] , asymptotically, expected value \\(\\theta\\) variance-covariance \\(\\left(\\sum_{j=1}^k I_j(\\theta)\\right)^{-1}\\).","code":""},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"example-2","dir":"Articles","previous_headings":"Weighted MLE: A Weighted Sum of MLEs","what":"Example 2","title":"Fitting Common Distributions to a DGP","text":"example, use normal fit. evaluate performance weighted MLE, generate sample \\(N=1000\\) observations \\(\\mathcal{N}(\\theta)\\) compute MLE observed sample, denoted \\(\\hat\\theta\\). divide observed sample \\(r=5\\) sub-samples, size \\(N/r=100\\), compute MLE sub-sampled, denoted \\(\\theta^{(1)},\\ldots,\\theta^{(r)}\\). Finally, weighted combination MLEs form weighted MLE, denoted \\(\\theta_w\\): show results following R code. First, show weighted MLE MSE: MLE total sample MSE : see \\(\\hat\\theta\\) \\(\\hat\\theta_w\\) model approximately sampling distribution.","code":"N <- 500 r <- 5 samp <- rnorm(N, mean = theta[1], sd = sqrt(theta[2])) samp.sub <- matrix(samp, nrow = r) mles.sub <- list(length = r) for (i in 1:r)     mles.sub[[i]] <- fit_normal(samp.sub[i,])  mle.wt <- mle_weighted(mles.sub) mle <- fit_normal(samp) params(mle.wt) #> [1] 1.98 8.71 round(mse(mle.wt), digits=3) #>       [,1]  [,2] #> [1,] 0.018 0.000 #> [2,] 0.000 0.313 params(mle) #> [1] 1.98 9.28 round(mse(mle), digits=3) #>       [,1]  [,2] #> [1,] 0.019 0.000 #> [2,] 0.000 0.345"},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"bootstrapping-the-mles","dir":"Articles","previous_headings":"","what":"Bootstrapping the MLEs","title":"Fitting Common Distributions to a DGP","text":"Let’s compare earlier results relied large sampling assumption bootstrapped MLE using mle_boot. First, mle_boot just wrapper boot objects objects like boot. Thus use mle_boot, first need call boot bootstrap MLE Weibull fit. just need wrap function takes data input returns MLE parameters pass mle_boot constructor: already printed theta.boot object, provided lot information , can obtain specified statistics Bootstrap MLE using standard interface algorithmic.mle, e.g.: see , part, results similar obtained using large sampling assumption.","code":"theta.boot <- mle_boot(     boot(data = x,          statistic = function(x, i) params(fit_weibull(x[i])),          R = 1000)) print(theta.boot) #> Maximum likelihood estimator of type mle_boot is normally distributed. #> The estimates of the parameters are given by: #> [1] 1.95 9.27 #> The standard error is  0.153 0.501 . #> The asymptotic 95% confidence interval of the parameters are given by: #>        2.5% 97.5% #> param1 1.64  2.23 #> param2 8.31 10.28 #> The MSE of the individual components in a multivariate estimator is: #>        [,1]   [,2] #> [1,] 0.0235 0.0283 #> [2,] 0.0283 0.2519 bias(theta.boot) #> [1]  0.0159 -0.0228"},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"goodness-of-fit","dir":"Articles","previous_headings":"","what":"Goodness-of-Fit","title":"Fitting Common Distributions to a DGP","text":"fitting model data precisely capture generative model \\(W\\). , good fit ? conduct goodness fit test, \\[\\begin{align}   H_0 &: \\text{data compatible Weibull distribution}\\\\   H_A &: \\text{data compatible Weibull distribution}. \\end{align}\\] perform test, use Cramer-von Mises test. test based Cramer-von Mises statistic, measure distance empirical distribution function data distribution function model. Cramer-von Mises statistic given \\[   \\hat D_n^2 = \\frac{1}{n}\\sum_{=1}^n \\left(\\hat F_n(x_i) - F(x_i)\\right)^2 \\] \\(\\hat F_n\\) empirical distribution function data \\(F\\) distribution function model. Looking \\(p\\)-value, see data compatible Weibull distribution. Now, let’s normal distribution: compatible data. However, Weibull distribution larger \\(p\\)-value, may suggest better fit. also AIC measure goodness fit. AIC given \\[   \\text{AIC} = -2\\log L + 2k, \\] \\(L\\) likelihood model \\(k\\) number parameters model. AIC measure tradeoff goodness fit complexity model. lower AIC value indicates better fit. Thus, according measure, Weibull distribution better fit.","code":"cramer.test <- function(obs.dat,ref.dat) {   stat <- CDFt::CramerVonMisesTwoSamples(obs.dat,ref.dat)   list(p.value=exp(-stat)/6.0,        cramer.stat=stat,        obs.size=length(obs.dat),        ref.size=length(ref.dat)) }  wei.shape <- params(theta.weibull)[1] wei.scale <- params(theta.weibull)[2] ref.dat <- rweibull(1000000, shape = wei.shape, scale = wei.scale) cramer.test(x, ref.dat) #> $p.value #> [1] 0.16 #>  #> $cramer.stat #> [1] 0.042 #>  #> $obs.size #> [1] 100 #>  #> $ref.size #> [1] 1000000 norm.mu <- params(theta.hat)[1] norm.var <- params(theta.hat)[2] ref.dat <- rnorm(1000000, mean = norm.mu, sd = sqrt(norm.var)) cramer.test(x, ref.dat) #> $p.value #> [1] 0.149 #>  #> $cramer.stat #> [1] 0.112 #>  #> $obs.size #> [1] 100 #>  #> $ref.size #> [1] 1000000 aic(theta.weibull) #> [1] 573 aic(theta.hat) #> [1] 583"},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"prediction-intervals","dir":"Articles","previous_headings":"","what":"Prediction Intervals","title":"Fitting Common Distributions to a DGP","text":"Frequently, actually interested predicting outcome random variable (vector) estimating parameters . observed sample \\(\\mathcal{D} = \\{T_i\\}_{=1}^n\\) \\(T_i \\sim N(\\mu,\\sigma^2)\\), \\(\\theta = (\\mu,\\sigma^2)^T\\) known. compute MLE \\(\\theta\\), , asymptotically, normally distributed mean \\(\\theta\\) variance-covariance \\(^{-1}(\\theta)/n\\). wish model uncertainty new observation, \\(\\hat{T}_{n+1}|\\mathcal{D}\\). considering uncertainty inherent Normal distribution uncertainty estimate \\(\\hat\\theta\\) \\(\\theta\\). particular, let \\(\\hat{T}_{n+1}|\\hat\\theta \\sim N(\\hat\\mu,\\hat\\sigma^2)\\) \\(\\hat\\theta \\sim N(\\theta,^{-1}(\\theta)/n)\\) (sampling distribution MLE). , joint distribution \\(\\hat{T}_{n+1}\\) \\(\\hat\\theta\\) pdf given \\[     f(t,\\theta) = f_{\\hat{T}|\\hat\\theta}(t|\\theta=(\\mu,\\sigma^2)) f_{\\hat\\theta}(\\theta), \\] thus find \\(f(t)\\), marginalize \\(\\theta\\), obtaining \\[     f(t) = \\int_{-\\infty}^\\infty \\int_{-\\infty}^{\\infty} f_{\\hat{T}_{n+1},\\hat\\mu,\\hat\\sigma^2}(t,\\mu,\\sigma^2) d\\mu d\\sigma^2. \\] Given information sample, uncertainty new observation characterized distribution \\[     \\hat{T}_{n+1} \\sim f(t). \\] greater variance \\(T_{n+1}|\\hat\\theta\\) , stated earlier, know \\(\\theta\\), uncertain estimate \\(\\hat\\theta\\). pred, compute predictive interval (PI) distribution \\(\\hat{T}_{n+1}\\) using Monte Carlo simulation, replace integral sum large number draws joint distribution \\(\\hat{T}_{n+1}\\) \\(\\hat\\theta\\) compute empirical quantiles. function pred takes arguments x, case mle object, sampler distribution random variable interest, case rweibull (sampler normal distribution). sampler must compatible output point(x), whether output scalar vector. compute PI \\(\\hat{T}_{n+1}\\): general, return \\(p\\)--\\(3\\) matrix, \\(p\\) dimension \\(T\\) columns mean, lower quantile, upper quantile predictive distribution. compare \\(T_{n+1}|\\hat\\theta\\)? can compute 95% quantile interval \\(T_{n+1}|\\hat\\theta\\) using qnorm function: see 95% quantile interval \\(T_{n+1}|\\hat\\theta\\) smaller \\(\\hat{T}_{n+1}\\), expected. , uncertainty parameter value \\(\\theta\\).","code":"pred(x=theta.hat, samp=function(n=1, theta) rnorm(n,theta[1],theta[2])) #>      mean lower upper #> [1,] 8.39 -29.8  46.6 mu <- params(theta.hat)[1] sd <- sqrt(params(theta.hat)[2]) c(mean=mu,lower=qnorm(.025,mean=mu, sd=sd),upper=qnorm(.975,mean=mu, sd=sd)) #>   mean  lower  upper  #>  8.230 -0.338 16.799"},{"path":"https://queelius.github.io/algebraic.mle/articles/fitting-common-dist.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Fitting Common Distributions to a DGP","text":"vignette, demonstrated use algebraic.mle package estimate sampling distribution MLE using large sampling assumption Bootstrap method. package provides various functions obtaining statistics MLE, allowing deeper understanding properties estimator. showed fit Weibull Normal distributions simulated dataset whose true distribution, known, common name. shown compare two models using Cramer-von Mises test AIC measure goodness fit. came definitive conclusion model better, Weibull distribution larger \\(p\\)-value Cramer-von Mises test, lower AIC value, serves evidence better fit. saw true DGP visually different Weibull normal distributions. Notably, DGP longer tails , suggesting even better fit may long-tail distribution like log-normal Pareto distribution.","code":""},{"path":"https://queelius.github.io/algebraic.mle/articles/statistics.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Statistics and characteristics of the MLE","text":"R package algebraic.mle can installed GitHub using devtools package R:","code":"install.packages(\"devtools\") devtools::install_github(\"queelius/algebraic.mle\")"},{"path":"https://queelius.github.io/algebraic.mle/articles/statistics.html","id":"normal-distribution","dir":"Articles","previous_headings":"","what":"Normal distribution","title":"Statistics and characteristics of the MLE","text":"going classic Normal distribution demonstrate use algebraic.mle. using reasons: ’s well-understood, can compare results known results. ’s common distribution, ’s useful good understanding properties. MLE multivariate, can demonstrate use algebraic.mle multivariate distributions. , first, define simple MLE solver normal distribution. can see, return mle object, give sub-class mle_normal (also subclass mle algebraic.dist’s dist) can specialize methods MLE normal distribution, e.g., bias.mle_normal show later.","code":"fit_normal <- function(data) {     sigma <- function(data) {         mean((data - mean(data))^2)     }     loglik <- function(par, data) {         n <- length(data)         -n / 2 * log(2 * pi * par[2]) - 1 / (2 * par[2]) *             (sum(data^2) - 2 * par[1] * sum(data) + n * par[1]^2)     }     par.hat <- c(mu = mean(data), var = sigma(data))     H <- numDeriv::hessian(func = loglik, x = par.hat, data = data)     algebraic.mle::mle(         theta.hat = par.hat,         loglike = loglik(par.hat, data),         score = numDeriv::grad(func = loglik, x = par.hat, data = data),         sigma = MASS::ginv(-H),         info = -H,         obs = NULL,         nobs = length(data),         superclasses = c(\"mle_normal\")) }"},{"path":"https://queelius.github.io/algebraic.mle/articles/statistics.html","id":"monte-carlo-mc-simulation-of-the-sampling-distribution-of-the-mle","dir":"Articles","previous_headings":"","what":"Monte-carlo (MC) simulation of the sampling distribution of the MLE","title":"Statistics and characteristics of the MLE","text":"Let’s define theta_samp_mc, stands Monte Carlo simulation sampling distribution MLE. takes sample size n, true parameter value theta, number simulations B run. returns matrix B rows two columns, first column MLE mean second column MLE variance. matrix mles sample MLEs sampling distribution MLE. empirical distribution MLE \\((\\mu, \\sigma^2)'\\) samples size \\(n\\) \\(X_i \\sim N(\\mu, \\sigma^2)\\) \\(=1,\\ldots,n\\). particular example Monte Carlo simulation sampling distribution, since simulating sampling distribution repeatedly sampling population distribution computing MLE sample. bootstrap, resample sample, population, large enough sample, two produce nearly identical results. See bootstrap section details, ’ll compare two. sufficiently large number simulations \\(B\\), empirical sampling distribution close true sampling distribution. can plot empirical sampling distribution MLEs using plot function mles matrix. Sampling distribution MLEs. algebraic.dist, can use empirical_dist represent empirical sampling distribution giving sample MLEs previously generated: general, MLE assuming regularity conditions hold, asymptotic sampling distribution MLE normal mean \\(\\theta\\) variance-covariance matrix \\(\\Sigma = ^{-1}(\\theta)_n\\), \\(\\) Fisher information matrix \\(n\\) sample size. However, general: don’t know asymptotic sampling distribution good approximation true sampling distribution. cases, empirical sampling distribution may used instead. may confident implementation MLE correct, case empirical sampling distribution can used check implementation. regularity conditions may hold, case asymptotic sampling distribution may known. cases, empirical sampling distribution may used instead. caveats mind, compare statistics empirical sampling distribution MLE normal distribution asymptotic sampling distribution. Let’s look basic parameters sampling distribution MLE normal distribution. First, let’s look mean: mean looks pretty close true parameter vector \\[     \\theta = (\\mu = 1, \\sigma^2 = 1)'. \\] can actually compute parameter, since theta.mc, models concept distribution. particular, models distribution algebraic.dist, thus API exposed algebraic.dist available us. instance, can compute various parameters sampling distribution MLE using expectation function: use mean variance-covariance matrix parameterize multivariate normal distribution (MVN), instance, don’t .","code":"theta_samp_mc <- function(n, theta, B = 10000) {     mu <- theta[1]     var <- theta[2]     mles <- matrix(NA, nrow = B, ncol = 2)     for (i in 1:B) {         d <- rnorm(n, mean = mu, sd = sqrt(var))         mles[i, ] <- params(fit_normal(d))     }     colnames(mles) <- c(\"mu\", \"var\")     mles } # Set up the parameters of a simulation set.seed(913254) n <- 70 mu <- 1 var <- 1 B <- 1000 theta <- c(mu, var) mles <- theta_samp_mc(n = n, theta = theta, B = B) head(mles) #>         mu   var #> [1,] 0.891 0.728 #> [2,] 1.033 1.102 #> [3,] 1.105 1.094 #> [4,] 1.146 0.832 #> [5,] 0.916 0.895 #> [6,] 0.986 0.904 theta.mc <- algebraic.dist::empirical_dist(mles) (mu.mc <- mean(theta.mc)) #>    mu   var  #> 0.995 0.982 # should sum to 1 expectation(theta.mc, function(x) 1) #> [1] 1 # mean expectation(theta.mc, function(x) x) #>    mu   var  #> 0.995 0.982 # variance of (mu, var) expectation(theta.mc, function(x) (x - mu.mc)^2) #>     mu    var  #> 0.0136 0.0282 # kurtosis of (mu, var)  expectation(theta.mc, function(x) (x - mu.mc)^4) /     expectation(theta.mc, function(x) (x - mu.mc)^2)^2 #>   mu  var  #> 2.77 3.21 # skewness of mu and var -- should be (0, 0) expectation(theta.mc, function(x) ((x - mu.mc) / theta)^3) #>        mu       var  #> 0.0000624 0.0016654 # covariance of (mu, var) -- should be around 0 expectation(theta.mc, function(x) (x[1] - mu.mc[1]) * (x[2] - mu.mc[2])) #> [1] 0.0000799"},{"path":"https://queelius.github.io/algebraic.mle/articles/statistics.html","id":"bias","dir":"Articles","previous_headings":"","what":"Bias","title":"Statistics and characteristics of the MLE","text":"Bias measure systematic error estimator; measures far average value true value estimated. Formally, defined difference expected value estimator true value parameter, .e., \\[ \\operatorname{Bias}(\\hat\\theta) = E_{\\hat\\theta}(\\hat\\theta) - \\theta, \\] \\(E_{\\hat\\theta}\\) denotes expectation operator respect sampling distribution \\(\\hat\\theta\\). (Normally, drop subscript expectation operator write \\(E\\) instead \\(E_{\\hat\\theta}\\) unless ’s clear context expectation operator using.) bias zero, estimator unbiased, otherwise biased. Analytically, asymptotic bias MLE parameters normal distribution \\[     \\operatorname{Bias}(\\hat\\theta) = \\left(\\begin{array}{c}         0 \\\\         -\\frac{\\sigma^2}{n}     \\end{array}\\right). \\] Plugging true value \\(\\sigma^2 = 1\\) sample size \\(n = 70\\), get \\((0, 0.014)\\). may also provide appropriate implementation bias method algebraic.mle mle_normal (called object returned fit_normal): Now, let’s compute bias using function, estimate bias provided bias.mle_emp: asymptotic bias empirical bias pretty close. Let’s see bias variance changes sample size increases.","code":"bias.mle_normal <- function(x, par = NULL, ...) {     if (is.null(par)) {         par <- params(x)     }     c(mu = 0, var = -(1 / nobs(x)) * par[2]) } # first, we sample some data from the true distribution data <- rnorm(n = n, mean = mu, sd = sqrt(var))  # now we fit it to the normal distribution theta.hat <- fit_normal(data)  # now we compute the bias, first using the asymptotic theory bias(theta.hat, theta) #>      mu     var  #>  0.0000 -0.0143 # now using the empirical sampling distribution expectation(theta.mc, function(x) x - theta) # mean(theta.mc) - theta #>       mu      var  #> -0.00507 -0.01768 N <- 1000 ns <- seq(25, 200, 25) bias_var <- numeric(length(ns)) j <- 1 for (n in ns) {     vars <- numeric(length(N))     for (i in 1:N) {         d <- rnorm(n = n, mean = mu, sd = sqrt(var))         fit <- fit_normal(d)         vars[i] <- params(fit)[2]     }     bias_var[j] <- mean(vars) - var     j <- j + 1 }"},{"path":"https://queelius.github.io/algebraic.mle/articles/statistics.html","id":"variance-covariance-matrix","dir":"Articles","previous_headings":"Bias","what":"Variance-covariance matrix","title":"Statistics and characteristics of the MLE","text":"variance-covariance matrix one important statistical measures estimator parameter vector. quantities variability individual parameter estimates co-vary . variance-covariance matrix parameter vector \\(\\theta = (\\theta_1, \\ldots, \\theta_p)'\\) \\(n \\times n\\) matrix defined \\[ \\operatorname{Var}(\\hat\\theta) = E_{\\hat\\theta}\\!\\bigl[(\\hat\\theta - E_{\\hat\\theta}(\\hat\\theta))     (\\hat\\theta - E_{\\hat\\theta}(\\hat\\theta))'\\bigr]. \\] \\((, j)\\)th element variance-covariance matrix covariance \\(\\)th \\(j\\)th elements parameter vector, respectively \\(\\theta_i\\) \\(\\theta_j\\). Thus, diagonal elements variance-covariance matrix variances individual parameter estimates, -diagonal elements covariances parameter estimates. look reasonably close, suggesting \\(n = 200\\), asymptotic sampling distribution good approximation “true” sampling distribution MLE.","code":"round(vcov(theta.hat), digits=3) #>       [,1]  [,2] #> [1,] 0.011 0.000 #> [2,] 0.000 0.017 round(vcov(theta.mc), digits=3) #>        mu   var #> mu  0.014 0.000 #> var 0.000 0.028"},{"path":"https://queelius.github.io/algebraic.mle/articles/statistics.html","id":"confidence-intervals","dir":"Articles","previous_headings":"Bias","what":"Confidence intervals","title":"Statistics and characteristics of the MLE","text":"can compute CI parameter using confint function: important measure accuracy estimator coverage probability, probability confidence interval parameter estimate contains true value parameter. coverage probability \\((1-\\alpha) \\%\\)-confidence interval \\(1-\\alpha\\), confidence interval said well-calibrated. coverage probability less \\(1-\\alpha\\), confidence interval said conservative; coverage probability greater \\(1-\\alpha\\), confidence interval said anti-conservative. can estimate simulating large number samples population distribution computing proportion times confidence interval contains true value parameter. can mean variance normal distribution.  see coverage probability close nominal coverage probability, converges sample size increases. suggests confidence intervals well-calibrated.","code":"confint(theta.hat) #>      2.5% 97.5% #> mu  0.724  1.14 #> var 0.522  1.04 N <- 1000 ns <- c(seq(50, 200, 50), 300, 600, 1000) coverage_prob <- matrix(NA, nrow=length(ns), ncol=2) j <- 1 for (n in ns) {     count1 <- 0L     count2 <- 0L     for (i in 1:N) {         d <- rnorm(n = n, mean = mu, sd = sqrt(var))         fit <- fit_normal(d)         ci <- confint(fit)         if (ci[1, 1] <= mu && mu <= ci[1, 2]) {             count1 <- count1 + 1         }         if (ci[2, 1] <= var && var <= ci[2, 2]) {             count2 <- count2 + 1         }     }     coverage_prob[j, 1] <- count1 / N     coverage_prob[j, 2] <- count2 / N     j <- j + 1 }"},{"path":"https://queelius.github.io/algebraic.mle/articles/statistics.html","id":"mean-squared-error-matrix","dir":"Articles","previous_headings":"","what":"Mean squared error matrix","title":"Statistics and characteristics of the MLE","text":"mean squared error (MSE) estimator parameter vector \\(\\theta\\) defined \\[ \\operatorname{MSE}(\\hat\\theta) = E\\bigl[(\\hat\\theta - \\theta)(\\hat\\theta - \\theta)'\\bigr], \\] \\(\\hat\\theta - \\theta\\) column vector differences estimator true parameter \\((\\hat\\theta - \\theta)'\\) row vector differences, performing standard matrix multiplication two vectors. MSE measure average squared error estimator. function true parameter value \\(\\theta\\). MSE matrix. similar variance-covariance matrix, defined \\[ \\operatorname{Var}(\\hat\\theta) = E\\bigl[(\\hat\\theta - E(\\hat\\theta))     (\\hat\\theta - E(\\hat\\theta))'\\bigr], \\] replace true paramater \\(\\theta\\) expected value estimator \\(\\hat\\theta\\). estimator unbiased, \\(E(\\hat\\theta) = \\theta\\) \\(\\operatorname{Var}(\\hat\\theta) = \\operatorname{MSE}(\\hat\\theta)\\). need consider estimation error parameter individually, also errors might relate . instance, case overestimate one parameter, tend underestimate another. kind relationship errors estimating different parameters can captured -diagonal elements MSE matrix, represent covariances errors. diagonal elements MSE represent MSE individual parameter estimators, e.g., \\(\\)th diagonal element represents \\(\\operatorname{MSE}(\\hat\\theta_j)\\). trace MSE, sum diagonal elements, represents total MSE across parameters. single summary statistic, may useful comparing different estimators. MSE can decomposed two parts: bias, difference expected value estimator true parameter value, variance, variance estimator. MSE computed sum bias outer product variance-covariance matrix: \\[ \\operatorname{MSE}(\\hat\\theta) = \\operatorname{Bias}(\\hat\\theta)\\operatorname{Bias}(\\hat\\theta)'     + \\operatorname{Var}(\\hat\\theta). \\] ’s hard distinguish MSE matrices variance-covariance matrices reported previously, surprising, since bias relatively small MSE dominated variance. Let’s take closer look variance MSE mean \\(\\hat\\mu\\): close, since bias small. take MSE Monte Carlo simulation sort “true” MSE, since computed empirical sampling distribution MLE. expect sample size increases, asymptotic MSE (mse.hat) MC MSE (mse.mc) converge value. fact, let’s run little experiment show :  plots demonstrate asymptotic MSE good approximation “true” MSE, MSE computed empirical sampling distribution MLE. ’s difficult distinguish estimated asymptotic MSE, true parameter \\(\\theta\\) known, asymptotic MSE, true parameter \\(\\theta\\) known. bias small, MSE dominated variance.","code":"mse.hat <- mse(theta.hat, theta) mse.mc <- matrix(expectation(theta.mc,     function(x) (x - theta) %*% t(x - theta)), nrow = 2)  round(mse.hat, digits = 3) #>         mu   var #> [1,] 0.011 0.000 #> [2,] 0.000 0.018 round(mse.mc, digits = 3) #>       [,1]  [,2] #> [1,] 0.014 0.000 #> [2,] 0.000 0.029 # temporarily show more digits in the numbers/outputs for this code block options(digits = 12) # mse(mu) expectation(theta.mc, function(x) (x[1] - mu)^2) #> [1] 0.013651619343 # variance(mu) (mu.var <- expectation(theta.mc, function(x) (x[1] - mean(theta.mc)[1])^2)) #> [1] 0.013625962941 b <- expectation(theta.mc, function(x) x[1] - mu) # mse = bias^2 + variance b^2 + mu.var #> [1] 0.013651619343 options(digits = 3) ns <- seq(25, 200, 25) mses.mc <- matrix(NA, nrow = length(ns), ncol = 2) mses.hat <- matrix(NA, nrow = length(ns), ncol = 2) mses.hat.hat <- matrix(NA, nrow = length(ns), ncol = 2) j <- 1 for (n in ns) {     theta.n <- empirical_dist(theta_samp_mc(n = n, theta = theta, B = B))     mse.mu.n <- expectation(theta.n, function(x) (x[1] - mu)^2)     mse.var.n <- expectation(theta.n, function(x) (x[2] - var)^2)     data <- rnorm(n = n, mean = mu, sd = sqrt(var))     fit <- fit_normal(data)     mses.mc[j, ] <- c(mse.mu.n, mse.var.n)     mses.hat[j, ] <- diag(mse(fit, theta))     mses.hat.hat[j, ] <- diag(mse(fit))     j <- j + 1 }"},{"path":"https://queelius.github.io/algebraic.mle/articles/statistics.html","id":"bootstrap-of-the-sampling-distribution-of-the-mle","dir":"Articles","previous_headings":"","what":"Bootstrap of the sampling distribution of the MLE","title":"Statistics and characteristics of the MLE","text":"Normally, don’t know true data generating process (DGP) data observe. sample data, want use sample estimate parameters model hopefully provides good fit DGP using maximum likelihood estimation. Earlier, simulated sample data normal distribution mean 1 variance 1 used MLE sample generate empirical sampling distribution MLE. called Monte Carlo simulation. However, can also use sample data generate empirical sampling distribution MLE. called bootstrap. idea sample sample true DGP, can use sample generate new samples (resample) fit MLE generate Bootstrapped empirical sampling distribution MLE. Let’s compute statistics: Let’s use Bootstrapped MLEs generate aproximation empirical sampling distribution: , let’s basic expectations Bootstrapped sampling distribution MLE compare previous results: bad. Let’s compute bias compare previous results: see bias function mle_boot bad. Note bias expectation w.r.t. sampling distribution MLE. general, can better estimator use \\[     \\hat\\theta^* = \\hat\\theta - \\operatorname{Bias}(\\hat\\theta), \\] assuming bias estimate accurate. particular example transformation makes worse, fine, bias transformed estimator less theory. Howevever, practice, don’t trust bias reported Bootstrap, except evidence estimator biased . analytic bias, bias.mle_normal, accurate, generally produce estimators less bias (although bias-variance trade-, may variance). Let’s compare variance-covariance matrix Bootstrapped sampling distribution MLE “true” sampling distribution asymptotic sampling distribution:","code":"# Simulate a sample of n observations from a normal with mean 1 and variance 2. library(boot) theta.boot <- mle_boot(boot(     data = data,     statistic = function(x, ind) {         params(fit_normal(x[ind]))     },     R = B)) params(theta.boot) #>   mu  var  #> 1.17 1.16 confint(theta.boot) #>      2.5% 97.5% #> mu  1.017  1.32 #> var 0.948  1.38 theta.b <- empirical_dist(theta.boot$t) # should sum to 1 expectation(theta.b, function(x) 1) #> [1] 1 # mean (mu.b <- mean(theta.b)) #> [1] 1.17 1.16 # variance of (mu, var) expectation(theta.b, function(x) (x - mu.b)^2) #> [1] 0.00593 0.01206 # kurtosis of (mu, var)  expectation(theta.b, function(x) (x - mu.b)^4) /     expectation(theta.b, function(x) (x - mu.b)^2)^2 #> [1] 2.87 3.20 # skewness of mu and var -- should be (0, 0) expectation(theta.b, function(x) ((x - mu.b) / theta)^3) #> [1] -0.0000276  0.0001810 # covariance of (mu, var) -- should be around 0 expectation(theta.b, function(x) (x[1] - mu.b[1]) * (x[2] - mu.b[2])) #> [1] -0.000997 bias(theta.boot) #>        mu       var  #>  0.000873 -0.003245 expectation(theta.mc, function(x) x - theta) #>       mu      var  #> -0.00507 -0.01768 bias(theta.hat, theta) #>      mu     var  #>  0.0000 -0.0143 round(vcov(theta.b), digits = 3) #>        [,1]   [,2] #> [1,]  0.006 -0.001 #> [2,] -0.001  0.012 round(vcov(theta.mc), digits = 3) #>        mu   var #> mu  0.014 0.000 #> var 0.000 0.028 round(vcov(theta.hat), digits = 3) #>       [,1]  [,2] #> [1,] 0.011 0.000 #> [2,] 0.000 0.017 N <- 100 ns <- c(50, 100) coverage_prob <- matrix(NA, nrow=length(ns), ncol=2) j <- 1 for (n in ns) {     count1 <- 0L     count2 <- 0L     for (i in 1:N) {         d <- rnorm(n = n, mean = mu, sd = sqrt(var))         fit.boot <- mle_boot(boot(             data = d,             statistic = function(x, ind) {                 params(fit_normal(x[ind]))             },             R = 250))         ci <- confint(fit.boot)         if (ci[1, 1] <= mu && mu <= ci[1, 2]) {             count1 <- count1 + 1         }         if (ci[2, 1] <= var && var <= ci[2, 2]) {             count2 <- count2 + 1         }     }     coverage_prob[j, 1] <- count1 / N     coverage_prob[j, 2] <- count2 / N     #cat(\"n = \", n, \", coverage = \", coverage_prob[j, ], \"\\n\")     j <- j + 1 }"},{"path":"https://queelius.github.io/algebraic.mle/articles/statistics.html","id":"prediction-intervals","dir":"Articles","previous_headings":"","what":"Prediction intervals","title":"Statistics and characteristics of the MLE","text":"Frequently, actually interested predicting outcome random variable (vector) estimating parameters . observed sample \\(\\mathcal{D} = \\{X_i\\}_{=1}^n\\) \\(X_i \\sim \\operatorname{Normal}(\\mu, \\sigma)\\), \\(\\theta = (\\mu, \\sigma)\\) known. estimate \\(\\theta\\), solved MLE , asymptotically, normally distributed mean \\(\\theta\\) variance-covariance given inverse FIM (, using Bootstrap, estimating covariance sampling distribution Bootstrapped MLEs). wish model uncertainty new observation, \\(\\hat{X}_{n+1}|\\mathcal{D}\\). considering uncertainty inherent Normal distribution uncertainty estimate \\(\\hat\\theta\\). particular, let \\(\\hat{X}_{n+1}|\\hat\\theta \\sim \\operatorname{Normal}(\\hat\\theta)\\) \\(\\hat\\theta \\sim \\operatorname{MVN}(\\theta,^{-1}(\\theta)/n)\\). , joint distribution \\(\\hat{X}_{n+1}\\) \\(\\hat\\theta\\) pdf given \\[     f(t,\\theta) = f_{\\hat{X}|\\hat\\theta}(x|\\theta) f_{\\hat\\theta}(\\theta), \\] thus find \\(f(t)\\), marginalize \\(\\theta\\), obtaining \\[     f(x) = \\int_{R^2} f_{\\hat{X}_{n+1},\\hat\\theta}(x,\\theta) d\\theta. \\] Given information sample, uncertainty new observation characterized distribution \\[     \\hat{X}_{n+1} \\sim f(x). \\] greater variance \\(X_{n+1}|\\hat\\theta\\) , stated earlier, know \\(\\theta\\), uncertain estimate \\(\\hat\\theta\\). pred, compute predictive interval (PI) distribution \\(\\hat{X}_{n+1}\\) using Monte Carlo integration, .e., sum large number draws joint distribution \\(\\hat{X}_{n+1}\\) \\(\\hat\\theta\\) compute empirical quantiles. function pred takes arguments x, case mle object, sampler distribution random variable interest, case rnorm (sampler normal distribution). sampler must compatible parameter value x (.e., params(x)). compute PI \\(\\hat{X}_{n+1}\\): compare \\(X_{n+1}|\\hat\\theta\\)? see 95% quantile interval \\(X_{n+1}|\\hat\\theta\\) bit smaller \\(\\hat{X}_{n+1}\\), expected. course, sufficiently large sample sizes, converge quantiles.","code":"samp <- function(n, par) rnorm(n = n, mean = par[1], sd = sqrt(par[2])) pred(x = theta.hat, samp = samp) #>       mean  lower upper #> [1,] 0.931 -0.821  2.67 par <- params(theta.hat) mu.hat <- par[1] var.hat <- par[2] c(mu.hat, qnorm(c(.025,.975), mean = mu.hat, sd = sqrt(var.hat))) #>     mu                #>  0.931 -0.801  2.663"},{"path":"https://queelius.github.io/algebraic.mle/articles/statistics.html","id":"weighted-mle-a-weighted-sum-of-maximum-likelihood-estimators","dir":"Articles","previous_headings":"","what":"Weighted MLE: a weighted sum of maximum likelihood estimators","title":"Statistics and characteristics of the MLE","text":"Since variance-covariance MLE inversely proportional FIM MLE defined respect , can combine multiple MLEs \\(\\theta\\), may defined respect different kind sample, arrive MLE incorporates Fisher information samples. Consider \\(k\\) mutually independent MLEs parameter \\(\\theta\\), \\(\\hat\\theta_1,\\ldots,\\hat\\theta_k\\), \\(\\hat\\theta_j \\sim N(\\theta,I_j^{-1}(\\theta))\\). , sampling MLE \\(\\theta\\) incorporates data \\(\\hat\\theta_1,\\ldots,\\hat\\theta_k\\) given inverse-variance weighted mean, \\[     \\hat\\theta_w = \\left(\\sum_{j=1}^k I_j(\\theta)\\right)^{-1} \\left(\\sum_{j=1}^k I_j(\\theta) \\hat\\theta_j\\right), \\] , asymptotically, expected value \\(\\theta\\) variance-covariance \\(\\left(\\sum_{j=1}^k I_j(\\theta)\\right)^{-1}\\). evaluate performance weighted MLE, generate sample \\(N=1000\\) observations \\(\\mathcal{N}(\\theta)\\) compute MLE observed sample, denoted \\(\\hat\\theta\\). divide observed sample \\(r=5\\) sub-samples, size \\(N/r=100\\), compute MLE sub-sampled, denoted \\(\\theta^{(1)},\\ldots,\\theta^{(r)}\\). Finally, weighted combination MLEs form weighted MLE, denoted \\(\\theta_w\\): show results following R code. First, show weighted MLE MSE: MLE total sample MSE : Unfortuantely, \\(\\hat\\theta\\) much better estimator \\(\\theta\\) \\(\\hat\\theta_w\\). According theory, identical, practice, may issues like numerical instability cause weighted MLE perform poorly. fact using numerical differentiation compute FIM, may source error. can try improve accuracy FIM using accurate method computing FIM, analytical solution accurate numerical approximation.","code":"N <- 100 r <- 5 samp <- rnorm(N, mean = theta[1], sd = sqrt(theta[2])) samp.sub <- matrix(samp, nrow = r) mles.sub <- list(length = r) for (i in 1:r)     mles.sub[[i]] <- fit_normal(samp.sub[i,])  mle.wt <- mle_weighted(mles.sub) mle <- fit_normal(samp) params(mle.wt) #> [1] 0.956 0.874 vcov(mle.wt) #>                    [,1]               [,2] #> [1,] 0.0092125971136169 0.0000000000000222 #> [2,] 0.0000000000000222 0.0161117644454432 params(mle) #>    mu   var  #> 0.993 1.003 vcov(mle) #>                    [,1]               [,2] #> [1,] 0.0100260496091190 0.0000000000000282 #> [2,] 0.0000000000000282 0.0201043341530873"},{"path":"https://queelius.github.io/algebraic.mle/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alexander Towell. Author, maintainer.","code":""},{"path":"https://queelius.github.io/algebraic.mle/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Towell (2023). algebraic.mle: Algebraic Maximum Likelihood Estimators. https://github.com/queelius/algebraic.mle, https://queelius.github.io/algebraic.mle/.","code":"@Manual{,   title = {algebraic.mle: Algebraic Maximum Likelihood Estimators},   author = {Alexander Towell},   year = {2023},   note = {https://github.com/queelius/algebraic.mle, https://queelius.github.io/algebraic.mle/}, }"},{"path":"https://queelius.github.io/algebraic.mle/reference/aic.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic method for obtaining the AIC of a fitted distribution object fit. — aic","title":"Generic method for obtaining the AIC of a fitted distribution object fit. — aic","text":"Generic method obtaining AIC fitted distribution object fit.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/aic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic method for obtaining the AIC of a fitted distribution object fit. — aic","text":"","code":"aic(x)"},{"path":"https://queelius.github.io/algebraic.mle/reference/aic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic method for obtaining the AIC of a fitted distribution object fit. — aic","text":"x object obtain AIC ","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/aic.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtaining the AIC of an `mle` object. — aic.mle","title":"Method for obtaining the AIC of an `mle` object. — aic.mle","text":"Method obtaining AIC `mle` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/aic.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtaining the AIC of an `mle` object. — aic.mle","text":"","code":"# S3 method for mle aic(x)"},{"path":"https://queelius.github.io/algebraic.mle/reference/aic.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtaining the AIC of an `mle` object. — aic.mle","text":"x `mle` object obtain AIC ","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/algebraic.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"`algebraic.mle`: A package for algebraically operating on and generating\nmaximum likelihood estimators from existing maximum likelihood estimators. — algebraic.mle","title":"`algebraic.mle`: A package for algebraically operating on and generating\nmaximum likelihood estimators from existing maximum likelihood estimators. — algebraic.mle","text":"object representing fitted model type `mle` object, maximum likelihood estimator model respect observed data.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/algebraic.mle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"`algebraic.mle`: A package for algebraically operating on and generating\nmaximum likelihood estimators from existing maximum likelihood estimators. — algebraic.mle","text":"relatively rich API working objects help understand MLE estimator.#'","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/bias.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic method for computing the bias of an estimator object. — bias","title":"Generic method for computing the bias of an estimator object. — bias","text":"Generic method computing bias estimator object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/bias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic method for computing the bias of an estimator object. — bias","text":"","code":"bias(x, theta, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/bias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic method for computing the bias of an estimator object. — bias","text":"x object compute bias . theta true parameter value. usually, unknown (NULL), case estimate bias ... pass additional arguments","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/bias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic method for computing the bias of an estimator object. — bias","text":"bias estimator. return type depends specific         method.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/bias.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the bias of an `mle` object assuming the large sample\napproximation is valid and the MLE regularity conditions are satisfied.\nIn this case, the bias is zero (or zero vector). — bias.mle","title":"Computes the bias of an `mle` object assuming the large sample\napproximation is valid and the MLE regularity conditions are satisfied.\nIn this case, the bias is zero (or zero vector). — bias.mle","text":"good estimate bias general, arguably better returning `NULL`.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/bias.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the bias of an `mle` object assuming the large sample\napproximation is valid and the MLE regularity conditions are satisfied.\nIn this case, the bias is zero (or zero vector). — bias.mle","text":"","code":"# S3 method for mle bias(x, theta = NULL, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/bias.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the bias of an `mle` object assuming the large sample\napproximation is valid and the MLE regularity conditions are satisfied.\nIn this case, the bias is zero (or zero vector). — bias.mle","text":"x `mle` object compute bias . theta true parameter value. normally, unknown (NULL), case estimate bias (say, using bootstrap) ... additional arguments pass","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/bias.mle_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the estimate of the bias of a `mle_boot` object. — bias.mle_boot","title":"Computes the estimate of the bias of a `mle_boot` object. — bias.mle_boot","text":"Computes estimate bias `mle_boot` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/bias.mle_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the estimate of the bias of a `mle_boot` object. — bias.mle_boot","text":"","code":"# S3 method for mle_boot bias(x, theta = NULL, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/bias.mle_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the estimate of the bias of a `mle_boot` object. — bias.mle_boot","text":"x `mle_boot` object compute bias . theta true parameter value (used `mle_boot`). ... pass additional arguments (used)","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/confint.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to compute the confidence intervals of `mle` objects. — confint.mle","title":"Function to compute the confidence intervals of `mle` objects. — confint.mle","text":"Function compute confidence intervals `mle` objects.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/confint.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to compute the confidence intervals of `mle` objects. — confint.mle","text":"","code":"# S3 method for mle confint(object, parm = NULL, level = 0.95, use_t_dist = FALSE, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/confint.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to compute the confidence intervals of `mle` objects. — confint.mle","text":"object `mle` object compute confidence intervals parm parameters compute confidence intervals (used) level confidence level, defaults 0.95 (alpha=.05) use_t_dist logical, whether use t-distribution compute confidence intervals. ... additional arguments pass","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/confint.mle_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtained the confidence interval of an `mle_boot` object.\nNote: This impelements the `vcov` method defined in `stats`. — confint.mle_boot","title":"Method for obtained the confidence interval of an `mle_boot` object.\nNote: This impelements the `vcov` method defined in `stats`. — confint.mle_boot","text":"Method obtained confidence interval `mle_boot` object. Note: impelements `vcov` method defined `stats`.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/confint.mle_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtained the confidence interval of an `mle_boot` object.\nNote: This impelements the `vcov` method defined in `stats`. — confint.mle_boot","text":"","code":"# S3 method for mle_boot confint(   object,   parm = NULL,   level = 0.95,   type = c(\"norm\", \"basic\", \"perc\", \"bca\"),   ... )"},{"path":"https://queelius.github.io/algebraic.mle/reference/confint.mle_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtained the confidence interval of an `mle_boot` object.\nNote: This impelements the `vcov` method defined in `stats`. — confint.mle_boot","text":"object `mle_boot` object obtain confidence interval parm parameter obtain confidence interval (used) level confidence level type type confidence interval compute ... additional arguments pass `boot.ci`","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/confint_from_sigma.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to compute the confidence intervals from a variance-covariance matrix — confint_from_sigma","title":"Function to compute the confidence intervals from a variance-covariance matrix — confint_from_sigma","text":"Function compute confidence intervals variance-covariance matrix","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/confint_from_sigma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to compute the confidence intervals from a variance-covariance matrix — confint_from_sigma","text":"","code":"confint_from_sigma(sigma, theta, level = 0.95)"},{"path":"https://queelius.github.io/algebraic.mle/reference/confint_from_sigma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to compute the confidence intervals from a variance-covariance matrix — confint_from_sigma","text":"sigma either variance-covariance matrix vector variances parameter estimator theta point estimate level confidence level, defaults 0.95 (alpha=.05)","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/expectation.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Expectation operator applied to `x` of type `mle`\nwith respect to a function `g`. That is, `E(g(x))`. — expectation.mle","title":"Expectation operator applied to `x` of type `mle`\nwith respect to a function `g`. That is, `E(g(x))`. — expectation.mle","text":"Optionally, use CLT construct CI(`alpha`) estimate expectation. , estimate `E(g(x))` sample mean Var(g(x)) sigma^2/n, sigma^2 sample variance g(x) n number samples. , construct CI.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/expectation.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expectation operator applied to `x` of type `mle`\nwith respect to a function `g`. That is, `E(g(x))`. — expectation.mle","text":"","code":"# S3 method for mle expectation(x, g = function(t) t, ..., control = list())"},{"path":"https://queelius.github.io/algebraic.mle/reference/expectation.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expectation operator applied to `x` of type `mle`\nwith respect to a function `g`. That is, `E(g(x))`. — expectation.mle","text":"x `mle` object g characteristic function interest, defaults identity ... additional arguments pass `g` control list control parameters: compute_stats - Whether compute CIs expectations, defaults                 FALSE n             - number samples use MC estimate,                 defaults 10000 alpha         - significance level confidence interval,                 defaults 0.05","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/expectation.mle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expectation operator applied to `x` of type `mle`\nwith respect to a function `g`. That is, `E(g(x))`. — expectation.mle","text":"`compute_stats` FALSE, estimate expectation,        otherwise list following components:   value - estimate expectation   ci    - confidence intervals component expectation   n     - number samples","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/is_mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if an object `x` is an `mle` object. — is_mle","title":"Determine if an object `x` is an `mle` object. — is_mle","text":"Determine object `x` `mle` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/is_mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if an object `x` is an `mle` object. — is_mle","text":"","code":"is_mle(x)"},{"path":"https://queelius.github.io/algebraic.mle/reference/is_mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if an object `x` is an `mle` object. — is_mle","text":"x object test","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/is_mle_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if an object is an `mle_boot` object. — is_mle_boot","title":"Determine if an object is an `mle_boot` object. — is_mle_boot","text":"Determine object `mle_boot` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/is_mle_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if an object is an `mle_boot` object. — is_mle_boot","text":"","code":"is_mle_boot(x)"},{"path":"https://queelius.github.io/algebraic.mle/reference/is_mle_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if an object is an `mle_boot` object. — is_mle_boot","text":"x object test","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/loglik_val.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic method for obtaining the log-likelihood value of a fitted MLE\nobject. — loglik_val","title":"Generic method for obtaining the log-likelihood value of a fitted MLE\nobject. — loglik_val","text":"Generic method obtaining log-likelihood value fitted MLE object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/loglik_val.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic method for obtaining the log-likelihood value of a fitted MLE\nobject. — loglik_val","text":"","code":"loglik_val(x, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/loglik_val.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic method for obtaining the log-likelihood value of a fitted MLE\nobject. — loglik_val","text":"x object obtain log-likelihood ... additional arguments pass","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/loglik_val.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtaining the log-likelihood of an `mle` object. — loglik_val.mle","title":"Method for obtaining the log-likelihood of an `mle` object. — loglik_val.mle","text":"Method obtaining log-likelihood `mle` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/loglik_val.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtaining the log-likelihood of an `mle` object. — loglik_val.mle","text":"","code":"# S3 method for mle loglik_val(x, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/loglik_val.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtaining the log-likelihood of an `mle` object. — loglik_val.mle","text":"x log-likelihood `l` evaluated `x`, `l(x)`. ... additional arguments pass","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/loglik_val.mle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method for obtaining the log-likelihood of an `mle` object. — loglik_val.mle","text":"log-likelihood fitted mle object `x`","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/marginal.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtaining the marginal distribution of an MLE\nthat is based on asymptotic assumptions: — marginal.mle","title":"Method for obtaining the marginal distribution of an MLE\nthat is based on asymptotic assumptions: — marginal.mle","text":"`x ~ MVN(params(x), inv(H)(x))`","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/marginal.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtaining the marginal distribution of an MLE\nthat is based on asymptotic assumptions: — marginal.mle","text":"","code":"# S3 method for mle marginal(x, indices)"},{"path":"https://queelius.github.io/algebraic.mle/reference/marginal.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtaining the marginal distribution of an MLE\nthat is based on asymptotic assumptions: — marginal.mle","text":"x distribution object. indices indices marginal distribution obtain.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/marginal.mle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method for obtaining the marginal distribution of an MLE\nthat is based on asymptotic assumptions: — marginal.mle","text":"H (observed expecation) Fisher information matrix.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor for making `mle` objects, which provides a common interface\nfor maximum likelihood estimators. — mle","title":"Constructor for making `mle` objects, which provides a common interface\nfor maximum likelihood estimators. — mle","text":"MLE makes asymptotic assumption default. MLEs, like `mle_boot`, may make assumption.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for making `mle` objects, which provides a common interface\nfor maximum likelihood estimators. — mle","text":"","code":"mle(   theta.hat,   loglike = NULL,   score = NULL,   sigma = NULL,   info = NULL,   obs = NULL,   nobs = NULL,   superclasses = NULL )"},{"path":"https://queelius.github.io/algebraic.mle/reference/mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for making `mle` objects, which provides a common interface\nfor maximum likelihood estimators. — mle","text":"theta.hat MLE loglike log-likelihood `theta.hat` given data score score function evaluated `theta.hat` sigma variance-covariance matrix `theta.hat` given data info information matrix `theta.hat` given data obs observation (sample) data nobs number observations `obs` superclasses class (classes) `mle` base","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrapped MLE — mle_boot","title":"Bootstrapped MLE — mle_boot","text":"Sometimes, large sample asymptotic theory MLEs applicable. cases, can use bootstrap estimate sampling distribution MLE.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrapped MLE — mle_boot","text":"","code":"mle_boot(x)"},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrapped MLE — mle_boot","text":"x `boot` return value","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_boot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrapped MLE — mle_boot","text":"`mle_boot` object (wrapper `boot` object)","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_boot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bootstrapped MLE — mle_boot","text":"takes approach similiar `mle_numerical` object, wrapper `stats::optim` return value, something compatible `optim` return value. , take `boot` object, sampling distribution MLE, wrap `mle_boot` object provide number methods `mle_boot` object satisfies concept `mle` object. Look `boot` package information bootstrap.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_numerical.html","id":null,"dir":"Reference","previous_headings":"","what":"This function takes the output of `optim`, `newton_raphson`, or `sim_anneal`\nand turns it into an `mle_numerical` (subclass of `mle`) object. — mle_numerical","title":"This function takes the output of `optim`, `newton_raphson`, or `sim_anneal`\nand turns it into an `mle_numerical` (subclass of `mle`) object. — mle_numerical","text":"function takes output `optim`, `newton_raphson`, `sim_anneal` turns `mle_numerical` (subclass `mle`) object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_numerical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function takes the output of `optim`, `newton_raphson`, or `sim_anneal`\nand turns it into an `mle_numerical` (subclass of `mle`) object. — mle_numerical","text":"","code":"mle_numerical(sol, options = list(), superclasses = NULL)"},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_numerical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function takes the output of `optim`, `newton_raphson`, or `sim_anneal`\nand turns it into an `mle_numerical` (subclass of `mle`) object. — mle_numerical","text":"sol output `optim` `newton_raphson` options list, options things like sigma FIM superclasses list, superclasses add `mle_numerical` object","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_numerical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function takes the output of `optim`, `newton_raphson`, or `sim_anneal`\nand turns it into an `mle_numerical` (subclass of `mle`) object. — mle_numerical","text":"`numerical_mle` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Accepts a list of `mle` objects for some parameter, say `theta`,\nand combines them into a single estimator `mle_weighted`. — mle_weighted","title":"Accepts a list of `mle` objects for some parameter, say `theta`,\nand combines them into a single estimator `mle_weighted`. — mle_weighted","text":"combines `mle` objects adding together, weighted inverse respective variance-covariance matrix (information matrix). Intuitively, higher variance, less weight `mle` given summation, alternatively, information parameter, weight given summation.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Accepts a list of `mle` objects for some parameter, say `theta`,\nand combines them into a single estimator `mle_weighted`. — mle_weighted","text":"","code":"mle_weighted(mles)"},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Accepts a list of `mle` objects for some parameter, say `theta`,\nand combines them into a single estimator `mle_weighted`. — mle_weighted","text":"mles list `mle` objects, parameter.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_weighted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Accepts a list of `mle` objects for some parameter, say `theta`,\nand combines them into a single estimator `mle_weighted`. — mle_weighted","text":"object type `mle_weighted` (inherits         `mle`) weighted sum `mle` objects.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mle_weighted.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Accepts a list of `mle` objects for some parameter, say `theta`,\nand combines them into a single estimator `mle_weighted`. — mle_weighted","text":"`mle` object `observed_fim` method, returns Fisher information matrix (FIM) parameter. FIM assumed negative expected value Hessian log-likelihood function. `mle` objects also `params` method, returns parameter vector. assume observations used estimate MLE objects `mles` independent.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mse.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic method for computing the mean squared error (MSE) of an estimator,\n`mse(x) = E[(x-mu)^2]` where `mu` is the true parameter value. — mse","title":"Generic method for computing the mean squared error (MSE) of an estimator,\n`mse(x) = E[(x-mu)^2]` where `mu` is the true parameter value. — mse","text":"Generic method computing mean squared error (MSE) estimator, `mse(x) = E[(x-mu)^2]` `mu` true parameter value.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic method for computing the mean squared error (MSE) of an estimator,\n`mse(x) = E[(x-mu)^2]` where `mu` is the true parameter value. — mse","text":"","code":"mse(x, theta)"},{"path":"https://queelius.github.io/algebraic.mle/reference/mse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic method for computing the mean squared error (MSE) of an estimator,\n`mse(x) = E[(x-mu)^2]` where `mu` is the true parameter value. — mse","text":"x object compute MSE theta true parameter value","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mse.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the MSE of an `mle` object. — mse.mle","title":"Computes the MSE of an `mle` object. — mse.mle","text":"MSE estimator just expected sum squared differences, e.g., true parameter value `x` estimator `x.hat`, MSE ```     mse(x.hat) = E[(x.hat-x)                        vcov(x.hat) + bias(x.hat, x)  ```","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mse.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the MSE of an `mle` object. — mse.mle","text":"","code":"# S3 method for mle mse(x, theta = NULL)"},{"path":"https://queelius.github.io/algebraic.mle/reference/mse.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the MSE of an `mle` object. — mse.mle","text":"x `mle` object compute MSE . theta true parameter value, defaults `NULL` unknown. `NULL`, let bias method deal . Maybe nice way estimating bias.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mse.mle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computes the MSE of an `mle` object. — mse.mle","text":"Since `x` typically known, normally must estimate bias. Asymptotically, assuming regularity conditions, bias MLE zero, can estimate MSE `mse(x.hat) = vcov(x.hat)`, small samples, generally case. can estimate bias, can replace bias estimate bias. Sometimes, can estimate bias analytically, , can use something like bootstrap. example, sample size `n`, can bootstrap bias sampling `n` observations replacement, computing MLE, computing difference bootstrapped MLE MLE. can repeat process `B` times, average differences get estimate bias.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mse.mle_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the estimate of the MSE of a `boot` object. — mse.mle_boot","title":"Computes the estimate of the MSE of a `boot` object. — mse.mle_boot","text":"Computes estimate MSE `boot` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/mse.mle_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the estimate of the MSE of a `boot` object. — mse.mle_boot","text":"","code":"# S3 method for mle_boot mse(x, theta = NULL, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/mse.mle_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the estimate of the MSE of a `boot` object. — mse.mle_boot","text":"x `boot` object compute MSE . theta true parameter value (used `mle_boot`) ... pass additional arguments `vcov`","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/nobs.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtaining the number of observations in the sample used by\nan `mle`. — nobs.mle","title":"Method for obtaining the number of observations in the sample used by\nan `mle`. — nobs.mle","text":"Method obtaining number observations sample used `mle`.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/nobs.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtaining the number of observations in the sample used by\nan `mle`. — nobs.mle","text":"","code":"# S3 method for mle nobs(object, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/nobs.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtaining the number of observations in the sample used by\nan `mle`. — nobs.mle","text":"object `mle` object obtain number observations ... additional arguments pass (used)","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/nobs.mle_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtaining the number of observations in the sample used by\nan `mle`. — nobs.mle_boot","title":"Method for obtaining the number of observations in the sample used by\nan `mle`. — nobs.mle_boot","text":"Method obtaining number observations sample used `mle`.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/nobs.mle_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtaining the number of observations in the sample used by\nan `mle`. — nobs.mle_boot","text":"","code":"# S3 method for mle_boot nobs(object, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/nobs.mle_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtaining the number of observations in the sample used by\nan `mle`. — nobs.mle_boot","text":"object `mle` object obtain number observations ... additional arguments pass (used)","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/nparams.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtaining the number of parameters of an `mle` object. — nparams.mle","title":"Method for obtaining the number of parameters of an `mle` object. — nparams.mle","text":"Method obtaining number parameters `mle` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/nparams.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtaining the number of parameters of an `mle` object. — nparams.mle","text":"","code":"# S3 method for mle nparams(x)"},{"path":"https://queelius.github.io/algebraic.mle/reference/nparams.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtaining the number of parameters of an `mle` object. — nparams.mle","text":"x `mle` object obtain number parameters ","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/nparams.mle_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtaining the number of parameters of an `boot` object. — nparams.mle_boot","title":"Method for obtaining the number of parameters of an `boot` object. — nparams.mle_boot","text":"Method obtaining number parameters `boot` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/nparams.mle_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtaining the number of parameters of an `boot` object. — nparams.mle_boot","text":"","code":"# S3 method for mle_boot nparams(x)"},{"path":"https://queelius.github.io/algebraic.mle/reference/nparams.mle_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtaining the number of parameters of an `boot` object. — nparams.mle_boot","text":"x `boot` object obtain number parameters ","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/obs.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtaining the observations used by the `mle` object `x`. — obs.mle","title":"Method for obtaining the observations used by the `mle` object `x`. — obs.mle","text":"Method obtaining observations used `mle` object `x`.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/obs.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtaining the observations used by the `mle` object `x`. — obs.mle","text":"","code":"# S3 method for mle obs(x)"},{"path":"https://queelius.github.io/algebraic.mle/reference/obs.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtaining the observations used by the `mle` object `x`. — obs.mle","text":"x `mle` object obtain number observations ","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/obs.mle_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtaining the observations used by the `mle`. — obs.mle_boot","title":"Method for obtaining the observations used by the `mle`. — obs.mle_boot","text":"Method obtaining observations used `mle`.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/obs.mle_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtaining the observations used by the `mle`. — obs.mle_boot","text":"","code":"# S3 method for mle_boot obs(x)"},{"path":"https://queelius.github.io/algebraic.mle/reference/obs.mle_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtaining the observations used by the `mle`. — obs.mle_boot","text":"x `mle` object obtain number observations ","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/observed_fim.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic method for computing the observed FIM\nof an `mle` object. — observed_fim","title":"Generic method for computing the observed FIM\nof an `mle` object. — observed_fim","text":"Fisher information way measuring amount information observable random variable `X` carries unknown parameter `theta` upon probability `X` depends.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/observed_fim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic method for computing the observed FIM\nof an `mle` object. — observed_fim","text":"","code":"observed_fim(x, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/observed_fim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic method for computing the observed FIM\nof an `mle` object. — observed_fim","text":"x object obtain fisher information ... additional arguments pass","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/observed_fim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generic method for computing the observed FIM\nof an `mle` object. — observed_fim","text":"inverse Fisher information matrix variance-covariance MLE `theta`. MLE objects observed FIM, e.g., MLE's sampling distribution bootstrapped.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/observed_fim.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Function for obtaining the observed FIM of an `mle` object. — observed_fim.mle","title":"Function for obtaining the observed FIM of an `mle` object. — observed_fim.mle","text":"Function obtaining observed FIM `mle` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/observed_fim.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function for obtaining the observed FIM of an `mle` object. — observed_fim.mle","text":"","code":"# S3 method for mle observed_fim(x, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/observed_fim.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function for obtaining the observed FIM of an `mle` object. — observed_fim.mle","text":"x `mle` object obtain FIM . ... pass additional arguments","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/orthogonal.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic method for determining the orthogonal parameters of an estimator. — orthogonal","title":"Generic method for determining the orthogonal parameters of an estimator. — orthogonal","text":"Generic method determining orthogonal parameters estimator.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/orthogonal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic method for determining the orthogonal parameters of an estimator. — orthogonal","text":"","code":"orthogonal(x, tol, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/orthogonal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic method for determining the orthogonal parameters of an estimator. — orthogonal","text":"x estimator tol tolerance determining number close enough zero ... additional arguments pass","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/orthogonal.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for determining the orthogonal components of an `mle` object\n`x`. — orthogonal.mle","title":"Method for determining the orthogonal components of an `mle` object\n`x`. — orthogonal.mle","text":"Method determining orthogonal components `mle` object `x`.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/orthogonal.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for determining the orthogonal components of an `mle` object\n`x`. — orthogonal.mle","text":"","code":"# S3 method for mle orthogonal(x, tol = sqrt(.Machine$double.eps), ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/orthogonal.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for determining the orthogonal components of an `mle` object\n`x`. — orthogonal.mle","text":"x `mle` object tol tolerance determining number close enough zero ... pass additional arguments","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/params.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtaining the parameters of an `mle` object. — params.mle","title":"Method for obtaining the parameters of an `mle` object. — params.mle","text":"Method obtaining parameters `mle` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/params.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtaining the parameters of an `mle` object. — params.mle","text":"","code":"# S3 method for mle params(x)"},{"path":"https://queelius.github.io/algebraic.mle/reference/params.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtaining the parameters of an `mle` object. — params.mle","text":"x `mle` object obtain parameters ","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/params.mle_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtaining the parameters of an `boot` object. — params.mle_boot","title":"Method for obtaining the parameters of an `boot` object. — params.mle_boot","text":"Method obtaining parameters `boot` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/params.mle_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtaining the parameters of an `boot` object. — params.mle_boot","text":"","code":"# S3 method for mle_boot params(x)"},{"path":"https://queelius.github.io/algebraic.mle/reference/params.mle_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtaining the parameters of an `boot` object. — params.mle_boot","text":"x `boot` object obtain parameters .","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/pred.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic method for computing the predictive confidence interval given an estimator object `x`. — pred","title":"Generic method for computing the predictive confidence interval given an estimator object `x`. — pred","text":"Generic method computing predictive confidence interval given estimator object `x`.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/pred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic method for computing the predictive confidence interval given an estimator object `x`. — pred","text":"","code":"pred(x, samp = NULL, alpha = 0.05, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/pred.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic method for computing the predictive confidence interval given an estimator object `x`. — pred","text":"x estimator object samp sampler random variable parameterized mle `x` alpha (1-alpha)/2 confidence interval ... additional arguments pass","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/pred.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate of predictive interval of `T|data` using Monte Carlo integration. — pred.mle","title":"Estimate of predictive interval of `T|data` using Monte Carlo integration. — pred.mle","text":"Let   `T|x ~ f(t|x)`` pdf vector `T` given MLE `x`   `x ~ MVN(params(x),vcov(x))`` estimate sampling distribution MLE parameters `T`. ,   `(T,x) ~ f(t,x) = f(t|x) f(x) joint distribution `(T,x)`. find `f(t)` fixed `t`, integrate `f(t,x)` `x` using Monte Carlo integration find marginal distribution `T`. , :","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/pred.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate of predictive interval of `T|data` using Monte Carlo integration. — pred.mle","text":"","code":"# S3 method for mle pred(x, samp, alpha = 0.05, R = 50000, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/pred.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate of predictive interval of `T|data` using Monte Carlo integration. — pred.mle","text":"x `mle` object. samp sampler distribution parameterized MLE `x`, .e., `T|x`. alpha (1-alpha)-predictive interval `T|x`. Defaults 0.05. R number samples draw sampling distribution `x`. Defaults 50000. ... additional arguments pass `samp`.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/pred.mle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate of predictive interval of `T|data` using Monte Carlo integration. — pred.mle","text":"1. Sample MVN `x` 2. Compute `f(t,x)` sample 3. Take mean `f(t,x)` values asn estimate `f(t)`. `samp` function used sample distribution `T|x`. designed take","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/print.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for obtaining the number of observations in the sample used by\nan `mle` object `x`. — print.mle","title":"Method for obtaining the number of observations in the sample used by\nan `mle` object `x`. — print.mle","text":"Method obtaining number observations sample used `mle` object `x`.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/print.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for obtaining the number of observations in the sample used by\nan `mle` object `x`. — print.mle","text":"","code":"# S3 method for mle print(x, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/print.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for obtaining the number of observations in the sample used by\nan `mle` object `x`. — print.mle","text":"x `mle` object print ... additional arguments pass","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/print.summary_mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Function for printing a `summary` object for an `mle` object. — print.summary_mle","title":"Function for printing a `summary` object for an `mle` object. — print.summary_mle","text":"Function printing `summary` object `mle` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/print.summary_mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function for printing a `summary` object for an `mle` object. — print.summary_mle","text":"","code":"# S3 method for summary_mle print(x, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/print.summary_mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function for printing a `summary` object for an `mle` object. — print.summary_mle","text":"x `summary_mle` object ... pass additional arguments","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/rmap.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the distribution of `g(x)` where `x` is an `mle` object. — rmap.mle","title":"Computes the distribution of `g(x)` where `x` is an `mle` object. — rmap.mle","text":"invariance property MLE, `x` `mle` object, right conditions, asymptotically, `g(x)` normally distributed,     g(x) ~ normal(g(point(x)),sigma) `sigma` variance-covariance `f(x)`","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/rmap.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the distribution of `g(x)` where `x` is an `mle` object. — rmap.mle","text":"","code":"# S3 method for mle rmap(x, g, ..., n = 1000L, method = c(\"mc\", \"delta\"))"},{"path":"https://queelius.github.io/algebraic.mle/reference/rmap.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the distribution of `g(x)` where `x` is an `mle` object. — rmap.mle","text":"x `mle` object g function ... additional arguments pass `g` function n number samples take estimate distribution `g(x)` `method == \"mc\"`. method method use estimate distribution `g(x)`, \"delta\" \"mc\".","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/rmap.mle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computes the distribution of `g(x)` where `x` is an `mle` object. — rmap.mle","text":"provide two different methods estimating variance-covariance `f(x)`:     method = \"delta\" -> delta method     method = \"mc\" -> monte carlo method","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/sampler.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for sampling from an `mle` object. — sampler.mle","title":"Method for sampling from an `mle` object. — sampler.mle","text":"creates sampler `mle` object. returns function accepts single parameter `n` denoting number samples draw `mle` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/sampler.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for sampling from an `mle` object. — sampler.mle","text":"","code":"# S3 method for mle sampler(x, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/sampler.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for sampling from an `mle` object. — sampler.mle","text":"x `mle` object create sampler ... additional arguments pass","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/sampler.mle_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for sampling from an `mle_boot` object. — sampler.mle_boot","title":"Method for sampling from an `mle_boot` object. — sampler.mle_boot","text":"creates sampler `mle_boot` object. returns function accepts single parameter `n` denoting number samples draw `mle_boot` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/sampler.mle_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for sampling from an `mle_boot` object. — sampler.mle_boot","text":"","code":"# S3 method for mle_boot sampler(x, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/sampler.mle_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for sampling from an `mle_boot` object. — sampler.mle_boot","text":"x `mle_boot` object create sampler ... additional arguments pass (used)","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/sampler.mle_boot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method for sampling from an `mle_boot` object. — sampler.mle_boot","text":"Unlike `sampler` method general `mle` objects, `mle_boot` objects, sample bootstrap replicates, representative sampling distribution, particularly small samples.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/score_val.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic method for computing the score of an estimator\nobject (gradient of its log-likelihood function evaluated\nat the MLE). — score_val","title":"Generic method for computing the score of an estimator\nobject (gradient of its log-likelihood function evaluated\nat the MLE). — score_val","text":"Generic method computing score estimator object (gradient log-likelihood function evaluated MLE).","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/score_val.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic method for computing the score of an estimator\nobject (gradient of its log-likelihood function evaluated\nat the MLE). — score_val","text":"","code":"score_val(x, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/score_val.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic method for computing the score of an estimator\nobject (gradient of its log-likelihood function evaluated\nat the MLE). — score_val","text":"x object compute score . ... pass additional arguments","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/score_val.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the score of an `mle` object (score evaluated at the MLE). — score_val.mle","title":"Computes the score of an `mle` object (score evaluated at the MLE). — score_val.mle","text":"reguarlity conditions satisfied, zero (approximately, rounding errors occur).","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/score_val.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the score of an `mle` object (score evaluated at the MLE). — score_val.mle","text":"","code":"# S3 method for mle score_val(x, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/score_val.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the score of an `mle` object (score evaluated at the MLE). — score_val.mle","text":"x `mle` object compute score . ... additional arguments pass (used)","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/se.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic method for obtaining the standard errors of an estimator. — se","title":"Generic method for obtaining the standard errors of an estimator. — se","text":"Generic method obtaining standard errors estimator.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/se.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic method for obtaining the standard errors of an estimator. — se","text":"","code":"se(x, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/se.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic method for obtaining the standard errors of an estimator. — se","text":"x estimator ... additional arguments pass","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/se.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Function for obtaining an estimate of the standard error of the MLE\nobject `x`. — se.mle","title":"Function for obtaining an estimate of the standard error of the MLE\nobject `x`. — se.mle","text":"Function obtaining estimate standard error MLE object `x`.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/se.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function for obtaining an estimate of the standard error of the MLE\nobject `x`. — se.mle","text":"","code":"# S3 method for mle se(x, se.matrix = FALSE, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/se.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function for obtaining an estimate of the standard error of the MLE\nobject `x`. — se.mle","text":"x MLE object se.matrix `TRUE`, return square root variance-covariance ... additional arguments pass (used)","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/summary.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Function for obtaining a summary of `object`, which is a fitted\n`mle` object. — summary.mle","title":"Function for obtaining a summary of `object`, which is a fitted\n`mle` object. — summary.mle","text":"Function obtaining summary `object`, fitted `mle` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/summary.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function for obtaining a summary of `object`, which is a fitted\n`mle` object. — summary.mle","text":"","code":"# S3 method for mle summary(object, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/summary.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function for obtaining a summary of `object`, which is a fitted\n`mle` object. — summary.mle","text":"object `mle` object ... pass additional arguments","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/vcov.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the variance-covariance matrix of `mle` object. — vcov.mle","title":"Computes the variance-covariance matrix of `mle` object. — vcov.mle","text":"Computes variance-covariance matrix `mle` object.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/vcov.mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the variance-covariance matrix of `mle` object. — vcov.mle","text":"","code":"# S3 method for mle vcov(object, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/vcov.mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the variance-covariance matrix of `mle` object. — vcov.mle","text":"object `mle` object obtain variance-covariance ... additional arguments pass (used)","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/vcov.mle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes the variance-covariance matrix of `mle` object. — vcov.mle","text":"variance-covariance matrix","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/vcov.mle_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the variance-covariance matrix of `boot` object.\nNote: This impelements the `vcov` method defined in `stats`. — vcov.mle_boot","title":"Computes the variance-covariance matrix of `boot` object.\nNote: This impelements the `vcov` method defined in `stats`. — vcov.mle_boot","text":"Computes variance-covariance matrix `boot` object. Note: impelements `vcov` method defined `stats`.","code":""},{"path":"https://queelius.github.io/algebraic.mle/reference/vcov.mle_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the variance-covariance matrix of `boot` object.\nNote: This impelements the `vcov` method defined in `stats`. — vcov.mle_boot","text":"","code":"# S3 method for mle_boot vcov(object, ...)"},{"path":"https://queelius.github.io/algebraic.mle/reference/vcov.mle_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the variance-covariance matrix of `boot` object.\nNote: This impelements the `vcov` method defined in `stats`. — vcov.mle_boot","text":"object `boot` object obtain variance-covariance ... additional arguments pass `stats::cov`","code":""}]
